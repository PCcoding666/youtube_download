"""YouTube video URL extractor service using yt-dlp.
Only extracts direct download URLs without downloading the video.
Traffic goes directly from user to Google servers.

Simplified architecture:
- PO Token: Auto-generated by bgutil-ytdlp-pot-provider plugin
- Cookies + Visitor Data: From AgentGo (optional)
"""
import yt_dlp
import asyncio
import logging
import time
from typing import Optional, Dict, Any, List
from pathlib import Path

from app.config import settings
from app.models import AuthenticationBundle

logger = logging.getLogger(__name__)


class ExtractionError(Exception):
    """Custom exception for URL extraction failures."""
    pass


class BotDetectionError(ExtractionError):
    """Exception for YouTube bot detection errors."""
    pass


def is_bot_detection_error(error_msg: str) -> bool:
    """Check if error message indicates YouTube bot detection."""
    bot_keywords = [
        'sign in to confirm',
        'not a bot',
        'confirm you\'re not a bot',
        'verify you are human',
        'captcha',
        'unusual traffic',
        'automated queries',
        'too many requests',
        'rate limit exceeded',
        'please try again later',
        'failed to extract any player response',
        'unable to extract',
        'sign in to confirm your age',
        '403'
    ]
    error_lower = error_msg.lower()
    return any(keyword in error_lower for keyword in bot_keywords)


class VideoFormat:
    """Represents a single video/audio format."""
    
    def __init__(self, fmt: Dict[str, Any]):
        self.format_id = fmt.get('format_id', '')
        self.url = fmt.get('url', '')
        self.ext = fmt.get('ext', '')
        self.resolution = fmt.get('resolution', 'audio only')
        self.height = fmt.get('height')
        self.width = fmt.get('width')
        self.fps = fmt.get('fps')
        self.vcodec = fmt.get('vcodec', 'none')
        self.acodec = fmt.get('acodec', 'none')
        self.filesize = fmt.get('filesize') or fmt.get('filesize_approx')
        self.tbr = fmt.get('tbr')  # Total bitrate
        self.format_note = fmt.get('format_note', '')
        self.protocol = fmt.get('protocol', '')  # https, m3u8, m3u8_native, etc.
    
    @property
    def is_video(self) -> bool:
        return self.vcodec != 'none' and self.vcodec is not None
    
    @property
    def is_audio(self) -> bool:
        return self.acodec != 'none' and self.acodec is not None
    
    @property
    def is_video_only(self) -> bool:
        return self.is_video and not self.is_audio
    
    @property
    def is_audio_only(self) -> bool:
        return self.is_audio and not self.is_video
    
    @property
    def has_both(self) -> bool:
        return self.is_video and self.is_audio
    
    @property
    def is_direct_download(self) -> bool:
        """Check if this is a direct download URL (not streaming)."""
        # https protocol means direct download from googlevideo.com
        return self.protocol == 'https' and self.url and 'googlevideo.com' in self.url
    
    @property
    def is_streaming(self) -> bool:
        """Check if this is a streaming format (m3u8/HLS)."""
        return self.protocol in ('m3u8', 'm3u8_native', 'hls') and self.url
    
    @property
    def is_usable(self) -> bool:
        """Check if this format has a usable URL (direct or streaming)."""
        return bool(self.url) and (self.is_direct_download or self.is_streaming)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'format_id': self.format_id,
            'url': self.url,
            'ext': self.ext,
            'resolution': self.resolution,
            'height': self.height,
            'width': self.width,
            'fps': self.fps,
            'vcodec': self.vcodec,
            'acodec': self.acodec,
            'filesize': self.filesize,
            'tbr': self.tbr,
            'format_note': self.format_note,
            'is_video': self.is_video,
            'is_audio': self.is_audio,
            'is_video_only': self.is_video_only,
            'is_audio_only': self.is_audio_only,
            'has_both': self.has_both,
            'protocol': self.protocol,
            'is_direct_download': self.is_direct_download,
            'is_streaming': self.is_streaming,
            'is_usable': self.is_usable
        }


class ExtractedVideo:
    """Represents extracted video information with download URLs."""
    
    def __init__(self, info: Dict[str, Any]):
        self.video_id = info.get('id', '')
        self.title = info.get('title', 'Unknown')
        self.duration = info.get('duration', 0)
        self.thumbnail = info.get('thumbnail', '')
        self.description = info.get('description', '')
        self.uploader = info.get('uploader', '')
        self.uploader_id = info.get('uploader_id', '')
        self.view_count = info.get('view_count', 0)
        self.like_count = info.get('like_count', 0)
        self.upload_date = info.get('upload_date', '')
        
        # Parse all formats
        self._formats = [VideoFormat(f) for f in info.get('formats', [])]
    
    @property
    def formats(self) -> List[VideoFormat]:
        return self._formats
    
    def get_best_video_audio_combined(self) -> Optional[VideoFormat]:
        """Get best format that has both video and audio."""
        combined = [f for f in self._formats if f.has_both and f.url]
        if not combined:
            return None
        return max(combined, key=lambda f: (f.height or 0, f.tbr or 0))
    
    def get_best_video_only(self, max_height: Optional[int] = None) -> Optional[VideoFormat]:
        """Get best video-only format (needs separate audio)."""
        video_only = [f for f in self._formats if f.is_video_only and f.url]
        if max_height:
            video_only = [f for f in video_only if f.height and f.height <= max_height]
        if not video_only:
            return None
        return max(video_only, key=lambda f: (f.height or 0, f.tbr or 0))
    
    def get_best_audio_only(self) -> Optional[VideoFormat]:
        """Get best audio-only format."""
        audio_only = [f for f in self._formats if f.is_audio_only and f.url]
        if not audio_only:
            return None
        return max(audio_only, key=lambda f: f.tbr or 0)
    
    def get_format_by_height(self, height: int) -> Optional[VideoFormat]:
        """Get format closest to specified height."""
        # First try combined formats
        combined = [f for f in self._formats if f.has_both and f.url and f.height]
        if combined:
            exact = [f for f in combined if f.height == height]
            if exact:
                return max(exact, key=lambda f: f.tbr or 0)
            # Get closest
            return min(combined, key=lambda f: abs((f.height or 0) - height))
        
        # Fall back to video-only
        video_only = [f for f in self._formats if f.is_video_only and f.url and f.height]
        if video_only:
            exact = [f for f in video_only if f.height == height]
            if exact:
                return max(exact, key=lambda f: f.tbr or 0)
            return min(video_only, key=lambda f: abs((f.height or 0) - height))
        
        return None
    
    def get_download_urls(self, resolution: str = "720", prefer_mp4: bool = True) -> Dict[str, Any]:
        """
        Get download URLs based on resolution preference.
        
        Priority order:
        1. Direct download (https) - can be downloaded directly
        2. Streaming (m3u8) - needs FFmpeg conversion for download
        
        Args:
            resolution: "360", "480", "720", "1080", "1440", "2160", "best", "audio"
            prefer_mp4: If True, prefer MP4 format over WEBM (default: True)
            
        Returns:
            Dict with video_url, audio_url (if separate), format info, and is_streaming flag
        """
        result = {
            'video_url': None,
            'audio_url': None,
            'video_format': None,
            'audio_format': None,
            'needs_merge': False,
            'is_streaming': False,  # True if m3u8, needs FFmpeg to download
            'resolution': resolution
        }
        
        def is_mp4_format(f) -> bool:
            """Check if format is MP4/M4A (H.264/AAC)."""
            return f.ext in ('mp4', 'm4a') or (f.vcodec and 'avc' in f.vcodec.lower())
        
        def format_sort_key(f, prefer_mp4: bool = True):
            """Sort key: (is_direct, is_mp4, height, bitrate)."""
            direct_score = 2 if f.is_direct_download else (1 if f.is_streaming else 0)
            mp4_score = 1 if (prefer_mp4 and is_mp4_format(f)) else 0
            return (direct_score, mp4_score, f.height or 0, f.tbr or 0)
        
        def select_best_format(formats: list, target_height: int, prefer_mp4: bool):
            """Select best format from list based on target height."""
            if not formats:
                return None
            if target_height == 9999:  # "best"
                return max(formats, key=lambda f: format_sort_key(f, prefer_mp4))
            
            suitable = [f for f in formats if f.height and f.height <= target_height]
            if suitable:
                return max(suitable, key=lambda f: format_sort_key(f, prefer_mp4))
            
            # Get closest to target
            candidates = sorted(formats, key=lambda f: abs((f.height or 0) - target_height))
            min_diff = abs((candidates[0].height or 0) - target_height)
            closest = [f for f in candidates if abs((f.height or 0) - target_height) == min_diff]
            return max(closest, key=lambda f: format_sort_key(f, prefer_mp4))
        
        # Handle audio-only request
        if resolution == "audio":
            audio_formats = [f for f in self._formats if f.is_audio_only and f.is_usable]
            if audio_formats:
                # Prefer direct download, then m4a
                audio_formats.sort(key=lambda f: (f.is_direct_download, f.ext == 'm4a', f.tbr or 0), reverse=True)
                audio = audio_formats[0]
                result['audio_url'] = audio.url
                result['audio_format'] = audio.to_dict()
                result['is_streaming'] = audio.is_streaming
            return result
        
        target_height = int(resolution) if resolution != "best" else 9999
        
        # Get all usable formats (direct + streaming)
        combined_formats = [f for f in self._formats if f.has_both and f.is_usable and f.height]
        video_only_formats = [f for f in self._formats if f.is_video_only and f.is_usable and f.height]
        audio_only_formats = [f for f in self._formats if f.is_audio_only and f.is_usable]
        
        # Find best candidates from each category
        best_combined = select_best_format(combined_formats, target_height, prefer_mp4) if combined_formats else None
        best_video_only = select_best_format(video_only_formats, target_height, prefer_mp4) if video_only_formats else None
        
        # Decide which strategy to use:
        # - If video_only can provide higher resolution closer to target, use it
        # - If combined meets target resolution, prefer it (no merge needed)
        # - Otherwise use whichever gets closer to target
        
        use_combined = False
        if best_combined and not best_video_only:
            use_combined = True
        elif best_video_only and not best_combined:
            use_combined = False
        elif best_combined and best_video_only:
            combined_height = best_combined.height or 0
            video_only_height = best_video_only.height or 0
            
            # If target is high res (>=720) and video_only can provide it but combined can't
            if target_height >= 720:
                if video_only_height >= target_height and combined_height < target_height:
                    use_combined = False  # Use video_only for high res
                elif combined_height >= target_height:
                    use_combined = True  # Combined meets target, prefer it
                else:
                    # Neither meets target, use whichever is closer
                    use_combined = combined_height >= video_only_height
            else:
                # For low res, prefer combined if it meets target
                use_combined = combined_height >= target_height or combined_height >= video_only_height
        
        if use_combined and best_combined:
            result['video_url'] = best_combined.url
            result['video_format'] = best_combined.to_dict()
            result['is_streaming'] = best_combined.is_streaming
            return result
        
        # Use video_only + audio
        if best_video_only:
            result['video_url'] = best_video_only.url
            result['video_format'] = best_video_only.to_dict()
            result['needs_merge'] = True
            result['is_streaming'] = best_video_only.is_streaming
            
            # Get best audio - prefer direct download and m4a
            if audio_only_formats:
                audio_only_formats.sort(
                    key=lambda f: (
                        f.is_direct_download,  # Prefer direct download
                        f.ext == 'm4a' if prefer_mp4 else f.ext == 'webm',
                        f.tbr or 0
                    ), 
                    reverse=True
                )
                audio = audio_only_formats[0]
                result['audio_url'] = audio.url
                result['audio_format'] = audio.to_dict()
            
            return result
        
        return result
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'video_id': self.video_id,
            'title': self.title,
            'duration': self.duration,
            'thumbnail': self.thumbnail,
            'description': self.description,
            'uploader': self.uploader,
            'uploader_id': self.uploader_id,
            'view_count': self.view_count,
            'like_count': self.like_count,
            'upload_date': self.upload_date,
            'format_count': len(self._formats)
        }


class YouTubeURLExtractor:
    """
    Extract direct download URLs from YouTube videos.
    Does NOT download the video - only extracts googlevideo.com URLs.
    PO Token is auto-handled by bgutil-ytdlp-pot-provider plugin.
    """
    
    USER_AGENT = (
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
        "AppleWebKit/537.36 (KHTML, like Gecko) "
        "Chrome/131.0.0.0 Safari/537.36"
    )
    
    def __init__(
        self,
        region: Optional[str] = None,
        auth_bundle: Optional[AuthenticationBundle] = None
    ):
        """
        Initialize URL extractor.
        
        Args:
            region: Geographic region for AgentGo browser session
            auth_bundle: Authentication data (cookies, visitor_data) from AgentGo
        """
        self.region = region
        self._auth_bundle = auth_bundle
        self._cookie_file: Optional[str] = None
        
        if self._auth_bundle and self._auth_bundle.cookie_file_path:
            self._cookie_file = self._auth_bundle.cookie_file_path
    
    def set_authentication_bundle(self, auth_bundle: Optional[AuthenticationBundle]):
        """Set authentication bundle for the extractor."""
        self._auth_bundle = auth_bundle
        if auth_bundle and auth_bundle.cookie_file_path:
            self._cookie_file = auth_bundle.cookie_file_path
            logger.info(f"Set cookie file: {auth_bundle.cookie_file_path}")
        else:
            self._cookie_file = None
    
    def _build_opts(self, strategy: int = 1) -> Dict[str, Any]:
        """Build yt-dlp options for URL extraction."""
        from app.config import settings
        
        opts = {
            'noplaylist': True,
            'skip_download': True,
            'quiet': False,
            'no_warnings': False,
            'extract_flat': False,
            'geo_bypass': True,
            'geo_bypass_country': 'US',
            # Don't set 'format' when skip_download=True, we want ALL formats
            # Don't fail if requested format is unavailable
            'ignore_no_formats_error': True,
        }
        
        # Add proxy if configured
        if settings.http_proxy:
            opts['proxy'] = settings.http_proxy
            logger.info(f"Using proxy: {settings.http_proxy}")
        
        # Add cookies if available (from AgentGo)
        if self._cookie_file and Path(self._cookie_file).exists():
            opts['cookiefile'] = self._cookie_file
            logger.info(f"Using cookie file: {self._cookie_file}")
        
        # Build extractor_args
        youtube_args = {}
        
        if strategy == 1:
            # Strategy 1: Use multiple clients for best format availability
            # android_sdkless + web_safari give direct https URLs
            # web client is SABR-restricted but bgutil provides PO Token
            youtube_args['player_client'] = ['android_sdkless', 'web_safari', 'web']
        elif strategy == 2:
            # Strategy 2: iOS + web fallback
            youtube_args['player_client'] = ['ios', 'web']
        elif strategy == 3:
            # Strategy 3: TV embedded (360p only, no PO Token needed)
            youtube_args['player_client'] = ['tv_embedded']
        
        # Add visitor_data if available (from AgentGo)
        if self._auth_bundle and self._auth_bundle.visitor_data:
            youtube_args['visitor_data'] = [self._auth_bundle.visitor_data]
            logger.info(f"Using visitor data (length: {len(self._auth_bundle.visitor_data)})")
        
        if youtube_args:
            opts['extractor_args'] = {'youtube': youtube_args}
        
        return opts
    
    async def extract(self, url: str) -> ExtractedVideo:
        """
        Extract video information and download URLs.
        PO Token is auto-generated by bgutil-ytdlp-pot-provider plugin.
        
        Args:
            url: YouTube video URL
            
        Returns:
            ExtractedVideo object with all format URLs
            
        Raises:
            ExtractionError: If extraction fails
        """
        start_time = time.time()
        errors = []
        
        # Try strategies: web (with bgutil PO Token), iOS, tv_embedded
        for strategy in [1, 2, 3]:
            try:
                logger.info(f"Trying extraction strategy {strategy} for {url[:50]}...")
                
                opts = self._build_opts(strategy)
                loop = asyncio.get_event_loop()
                
                def do_extract():
                    with yt_dlp.YoutubeDL(opts) as ydl:
                        return ydl.extract_info(url, download=False)
                
                info = await loop.run_in_executor(None, do_extract)
                
                if info:
                    duration = time.time() - start_time
                    logger.info(f"Extraction succeeded with strategy {strategy} in {duration:.2f}s")
                    return ExtractedVideo(info)
                    
            except Exception as e:
                error_msg = str(e)
                errors.append(f"Strategy {strategy}: {error_msg}")
                logger.warning(f"Strategy {strategy} failed: {error_msg}")
                continue
        
        # Try AgentGo fallback
        try:
            result = await self._try_agentgo_fallback(url)
            if result:
                return result
        except Exception as e:
            errors.append(f"AgentGo fallback: {e}")
        
        raise ExtractionError(f"All extraction strategies failed: {'; '.join(errors[-3:])}")
    
    async def _try_agentgo_fallback(self, url: str) -> Optional[ExtractedVideo]:
        """Try AgentGo to get fresh cookies and visitor_data, then retry extraction."""
        try:
            from app.services.agentgo_service import get_agentgo_service
            
            service = get_agentgo_service()
            if not service.is_configured():
                logger.warning("AgentGo not configured for fallback")
                return None
            
            logger.info(f"Fetching authentication via AgentGo (region: {self.region or 'default'})...")
            auth_bundle = await service.get_youtube_authentication_bundle(
                force_refresh=True,
                region=self.region,
                video_url=url
            )
            
            if not auth_bundle:
                logger.error("Failed to get authentication from AgentGo")
                return None
            
            self.set_authentication_bundle(auth_bundle)
            logger.info(f"Got fresh auth: cookies={bool(auth_bundle.cookies)}, visitor_data={bool(auth_bundle.visitor_data)}")
            
            # Retry with web client (bgutil will provide PO Token)
            opts = self._build_opts(strategy=1)
            loop = asyncio.get_event_loop()
            
            def do_extract():
                with yt_dlp.YoutubeDL(opts) as ydl:
                    return ydl.extract_info(url, download=False)
            
            info = await loop.run_in_executor(None, do_extract)
            
            if info:
                logger.info("AgentGo fallback extraction succeeded")
                return ExtractedVideo(info)
            
            return None
            
        except ImportError:
            logger.warning("AgentGo service not available")
            return None
        except Exception as e:
            logger.error(f"AgentGo fallback error: {e}")
            return None
    
    async def prefetch_authentication(self):
        """Pre-fetch authentication bundle for the configured region."""
        if not self.region:
            return
        
        try:
            from app.services.agentgo_service import get_agentgo_service
            
            service = get_agentgo_service()
            if not service.is_api_configured():
                return
            
            auth_bundle = await service.get_youtube_authentication_bundle(region=self.region)
            if auth_bundle and not auth_bundle.is_expired():
                self.set_authentication_bundle(auth_bundle)
                logger.info(f"Pre-fetched authentication for region: {self.region}")
                
        except Exception as e:
            logger.warning(f"Failed to prefetch authentication: {e}")


async def extract_youtube_urls(
    url: str,
    resolution: str = "720",
    region: Optional[str] = None,
    auth_bundle: Optional[AuthenticationBundle] = None,
    timeout: int = 60
) -> Dict[str, Any]:
    """
    Quick function to extract YouTube download URLs.
    PO Token is auto-generated by bgutil-ytdlp-pot-provider plugin.
    
    Args:
        url: YouTube video URL
        resolution: "360", "480", "720", "1080", "best", "audio"
        region: Geographic region for AgentGo
        auth_bundle: Optional authentication bundle
        timeout: Extraction timeout in seconds
        
    Returns:
        Dict with video info and download URLs
    """
    extractor = YouTubeURLExtractor(region=region, auth_bundle=auth_bundle)
    
    # Pre-fetch auth if region specified
    if region and not auth_bundle:
        try:
            await asyncio.wait_for(extractor.prefetch_authentication(), timeout=30)
        except asyncio.TimeoutError:
            logger.warning("Authentication prefetch timed out")
        except Exception as e:
            logger.warning(f"Authentication prefetch failed: {e}")
    
    # Extract video info
    video = await asyncio.wait_for(extractor.extract(url), timeout=timeout)
    
    # Get download URLs for requested resolution
    urls = video.get_download_urls(resolution)
    
    return {
        'video_info': video.to_dict(),
        'download_urls': urls,
        'all_formats': [f.to_dict() for f in video.formats if f.url]
    }
