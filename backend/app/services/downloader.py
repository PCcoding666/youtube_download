"""YouTube video downloader service using yt-dlp.
Simplified architecture:
- Uses bgutil server for PO Token generation (fetched directly via HTTP)
- Uses AgentGo for Cookies and Visitor Data extraction
- No local proxy dependency - designed for server deployment
"""
import yt_dlp
import asyncio
import logging
import time
from typing import Optional, Dict, Any, Tuple, List
from pathlib import Path
import re

from app.config import settings
from app.models import AuthenticationBundle
from app.services.po_token_provider import get_po_token_provider

logger = logging.getLogger(__name__)


class ProxyRotator:
    """Stub proxy rotator for backward compatibility."""
    
    def __init__(self):
        self.failed_proxies = set()
        self._proxies = []
    
    def __len__(self):
        return len(self._proxies)
    
    def get_all(self):
        return self._proxies
    
    def get_random(self):
        return None


# Global proxy rotator instance (stub for backward compatibility)
_proxy_rotator = ProxyRotator()


def get_proxy_rotator() -> ProxyRotator:
    """Get the global proxy rotator instance."""
    return _proxy_rotator


class DownloadError(Exception):
    """Custom exception for download failures."""
    pass


class BotDetectionError(DownloadError):
    """Exception for YouTube bot detection errors."""
    pass


def is_bot_detection_error(error_msg: str) -> bool:
    """
    Check if error message indicates YouTube bot detection.
    
    Args:
        error_msg: Error message string
        
    Returns:
        True if error is related to bot detection
    """
    bot_keywords = [
        'sign in to confirm',
        'not a bot',
        'confirm you\'re not a bot',
        'verify you are human',
        'captcha',
        'unusual traffic',
        'automated queries',
        'too many requests',
        'rate limit exceeded',
        'please try again later',
        'failed to extract any player response',
        'unable to extract',
        'sign in to confirm your age'
    ]
    error_lower = error_msg.lower()
    return any(keyword in error_lower for keyword in bot_keywords)


class YouTubeDownloader:
    """
    Simplified YouTube downloader.
    
    Architecture:
    - PO Token: Auto-generated by bgutil-ytdlp-pot-provider plugin (runs as Docker sidecar)
    - Cookies + Visitor Data: Extracted via AgentGo cloud browser
    - No local proxy - direct connection or AgentGo's built-in proxy
    """
    
    USER_AGENT = (
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
        "AppleWebKit/537.36 (KHTML, like Gecko) "
        "Chrome/131.0.0.0 Safari/537.36"
    )
    
    def __init__(
        self, 
        resolution: str = "720",
        region: Optional[str] = None,
        auth_bundle: Optional[AuthenticationBundle] = None
    ):
        """
        Initialize downloader.
        
        Args:
            resolution: Video resolution (360, 480, 720, 1080, 1440, 2160, best, audio)
            region: Geographic region for AgentGo browser session
            auth_bundle: Authentication data (cookies, visitor_data) from AgentGo
        """
        self.resolution = resolution
        self.region = region
        self._auth_bundle: Optional[AuthenticationBundle] = auth_bundle
        self._cookie_file: Optional[str] = None
        
        if self._auth_bundle and self._auth_bundle.cookie_file_path:
            self._cookie_file = self._auth_bundle.cookie_file_path
    
    def configure_with_tokens(self, auth_bundle: AuthenticationBundle) -> Dict[str, Any]:
        """
        Configure yt-dlp extractor_args with visitor_data from authentication bundle.
        PO Token is fetched directly from bgutil server.
        
        Args:
            auth_bundle: Authentication bundle containing visitor_data and cookies
            
        Returns:
            Dictionary of extractor_args for yt-dlp configuration
        """
        # Fetch PO Token from bgutil server
        po_token = None
        try:
            provider = get_po_token_provider()
            if provider.is_available():
                po_token = provider.get_po_token()
        except Exception as e:
            logger.warning(f"Failed to get PO Token: {e}")
        
        # Base configuration
        extractor_args = {
            'youtube': {
                'player_client': ['mweb', 'web']
            }
        }
        
        # Add PO Token if available
        if po_token:
            extractor_args['youtube']['po_token'] = [f"mweb.gvs+{po_token}"]
            logger.info(f"✓ Configured yt-dlp with PO Token")
        
        # Add visitor data if available (from AgentGo)
        if auth_bundle.visitor_data:
            extractor_args['youtube']['visitor_data'] = auth_bundle.visitor_data
            logger.info(f"✓ Configured yt-dlp with visitor data (length: {len(auth_bundle.visitor_data)})")
        
        return extractor_args
    
    def set_authentication_bundle(self, auth_bundle: Optional[AuthenticationBundle]):
        """
        Set authentication bundle for the downloader.
        
        Args:
            auth_bundle: Authentication bundle to use, or None to clear
        """
        if auth_bundle:
            bundle_info = {
                'region': auth_bundle.region,
                'has_visitor_data': bool(auth_bundle.visitor_data),
                'cookies_count': len(auth_bundle.cookies) if auth_bundle.cookies else 0,
                'has_cookie_file': bool(auth_bundle.cookie_file_path),
            }
            logger.info(f"Updated authentication bundle: {bundle_info}")
            
            if hasattr(auth_bundle, 'is_expired') and auth_bundle.is_expired():
                logger.warning(f"Authentication bundle for region {auth_bundle.region} has expired")
            
            self._auth_bundle = auth_bundle
            
            if auth_bundle.cookie_file_path:
                self._cookie_file = auth_bundle.cookie_file_path
        else:
            logger.info("Cleared authentication bundle")
            self._auth_bundle = None
            self._cookie_file = None
    
    def _progress_hook(self, d: Dict[str, Any]) -> None:
        """Progress hook for yt-dlp to track download status."""
        if d['status'] == 'downloading':
            percent = d.get('_percent_str', '0%')
            speed = d.get('_speed_str', 'N/A')
            logger.info(f"Downloading: {percent} at {speed}")
        elif d['status'] == 'finished':
            logger.info("Download completed, now post-processing...")
        elif d['status'] == 'error':
            logger.error(f"Download error: {d.get('error', 'Unknown error')}")
        """Progress hook for yt-dlp to track download status."""
        if d['status'] == 'downloading':
            percent = d.get('_percent_str', '0%')
            speed = d.get('_speed_str', 'N/A')
            logger.info(f"Downloading: {percent} at {speed}")
        elif d['status'] == 'finished':
            logger.info("Download completed, now post-processing...")
        elif d['status'] == 'error':
            logger.error(f"Download error: {d.get('error', 'Unknown error')}")
    
    def _get_format_string(self) -> str:
        """
        Get yt-dlp format string based on resolution setting.
        Following yt-dlp community best practices for quality selection.
        
        Returns:
            Format string for yt-dlp
        """
        if self.resolution == "audio":
            return "bestaudio/best"
        elif self.resolution == "best":
            # Best quality with proper codec preference (VP9 > AVC1)
            return "bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo+bestaudio/best"
        else:
            # Specific resolution with quality-aware selection
            # Following yt-dlp community recommendation:
            # 1. Prefer mp4 container for compatibility
            # 2. Prefer AVC1 (H.264) codec for better quality at same resolution
            # 3. Use height filter to match exact resolution
            # 4. Fallback to best available if exact match not found
            height = int(self.resolution)
            return (
                f"bestvideo[height={height}][ext=mp4]+bestaudio[ext=m4a]/"
                f"bestvideo[height={height}]+bestaudio/"
                f"bestvideo[height<={height}][ext=mp4]+bestaudio[ext=m4a]/"
                f"bestvideo[height<={height}]+bestaudio/"
                f"best[height<={height}]/best"
            )
    
    def _build_base_config(self) -> Dict[str, Any]:
        """Build base yt-dlp configuration."""
        opts = {
            'noplaylist': True,
            'retries': 10,
            'fragment_retries': 10,
            'socket_timeout': 60,
            'format': self._get_format_string(),
            'merge_output_format': 'mp4' if self.resolution != "audio" else 'mp3',
            
            'http_headers': {
                'User-Agent': self.USER_AGENT,
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.9',
                'Accept-Encoding': 'gzip, deflate, br',
                'Sec-Ch-Ua': '"Chromium";v="131", "Not_A Brand";v="24"',
                'Sec-Ch-Ua-Mobile': '?0',
                'Sec-Ch-Ua-Platform': '"Windows"',
            },
            
            'no_cache_dir': True,
            'geo_bypass': True,
            'geo_bypass_country': 'US',
            
            'sleep_interval': 1,
            'max_sleep_interval': 3,
            'sleep_interval_requests': 1,
            
            'quiet': False,
            'no_warnings': False,
            'progress_hooks': [self._progress_hook],
            'logger': logger,
        }
        
        # Add proxy if configured
        if settings.http_proxy:
            opts['proxy'] = settings.http_proxy
            logger.info(f"Using proxy: {settings.http_proxy}")
        
        if self.resolution == "audio":
            opts['postprocessors'] = [{
                'key': 'FFmpegExtractAudio',
                'preferredcodec': 'mp3',
                'preferredquality': '192',
            }]
        
        # Add cookies if available (from AgentGo)
        if self._cookie_file and Path(self._cookie_file).exists():
            opts['cookiefile'] = self._cookie_file
            logger.info(f"Using cookie file: {self._cookie_file}")
        
        return opts
    
    def _get_strategy_config(self, strategy: int) -> Dict[str, Any]:
        """
        Get configuration for specific download strategy.
        PO Token is fetched directly from bgutil server when needed.
        
        Args:
            strategy: Strategy number (1-3)
            
        Returns:
            Strategy-specific yt-dlp options
        """
        # 策略优先级：
        # 1. android_sdkless + web_safari - 不需要 PO Token，最稳定
        # 2. mweb - 需要 PO Token
        # 3. tv_embedded - 最后手段，只有 360p
        
        strategies = {
            1: {
                # Strategy 1: android_sdkless + web_safari (最稳定，不需要 PO Token)
                'extractor_args': {
                    'youtube': {
                        'player_client': ['android_sdkless', 'web_safari'],
                    }
                }
            },
            2: {
                # Strategy 2: mweb with PO Token
                'extractor_args': {
                    'youtube': {
                        'player_client': ['mweb', 'web'],
                    }
                }
            },
            3: {
                # Strategy 3: TV Embedded client (last resort, 360p only)
                'extractor_args': {
                    'youtube': {
                        'player_client': ['tv_embedded'],
                    }
                }
            }
        }
        
        config = strategies.get(strategy, strategies[1])
        
        # Strategy 2 需要 PO Token
        if strategy == 2:
            try:
                provider = get_po_token_provider()
                if provider.is_available():
                    po_token = provider.get_po_token()
                    if po_token:
                        config['extractor_args']['youtube']['po_token'] = [f"mweb.gvs+{po_token}"]
                        logger.info(f"✓ Got PO Token from bgutil server")
            except Exception as e:
                logger.warning(f"Failed to get PO Token: {e}")
        
        # Add visitor_data if available (from AgentGo)
        if self._auth_bundle and self._auth_bundle.visitor_data:
            config['extractor_args']['youtube']['visitor_data'] = self._auth_bundle.visitor_data
            logger.debug(f"Added visitor data to strategy {strategy}")
        
        return config
    
    def _sanitize_filename(self, filename: str) -> str:
        """Remove or replace characters that are invalid in filenames."""
        # Replace invalid characters with underscore
        sanitized = re.sub(r'[<>:"/\\|?*]', '_', filename)
        # Remove leading/trailing spaces and dots
        sanitized = sanitized.strip('. ')
        # Limit length
        if len(sanitized) > 200:
            sanitized = sanitized[:200]
        return sanitized
    
    async def get_video_info(self, url: str) -> Optional[Dict[str, Any]]:
        """
        Extract video information without downloading.
        
        Args:
            url: YouTube video URL
            
        Returns:
            Video metadata dict or None if failed
        """
        # Get a proxy for info extraction
        proxy = None
        if self.use_rotation and self.proxy_rotator:
            proxy = self.proxy_rotator.get_random()
        else:
            proxy = self.current_proxy
        
        opts = self._build_base_config(proxy)
        opts['skip_download'] = True
        opts.update(self._get_strategy_config(1))
        
        try:
            loop = asyncio.get_event_loop()
            
            def extract():
                with yt_dlp.YoutubeDL(opts) as ydl:
                    return ydl.extract_info(url, download=False)
            
            info = await loop.run_in_executor(None, extract)
            
            return {
                'title': info.get('title', 'Unknown'),
                'duration': info.get('duration', 0),
                'thumbnail': info.get('thumbnail'),
                'description': info.get('description'),
                'uploader': info.get('uploader'),
                'view_count': info.get('view_count'),
            }
        except Exception as e:
            logger.error(f"Failed to extract video info: {e}")
            return None
    
    async def download_with_enhanced_auth(
        self, 
        url: str, 
        output_dir: str,
        auth_bundle: Optional[AuthenticationBundle] = None
    ) -> Tuple[str, Dict[str, Any]]:
        """
        Download YouTube video using enhanced authentication with tokens.
        
        Args:
            url: YouTube video URL
            output_dir: Local directory to save video
            auth_bundle: Optional authentication bundle to use
            
        Returns:
            Tuple of (video file path, video info dict)
            
        Raises:
            DownloadError: If all download strategies and proxies fail
        """
        # Set authentication bundle if provided
        if auth_bundle:
            self.set_authentication_bundle(auth_bundle)
        
        # Use the existing download method which now supports tokens
        return await self.download(url, output_dir)
    
    async def download(self, url: str, output_dir: str) -> Tuple[str, Dict[str, Any]]:
        """
        Download YouTube video using fallback strategies.
        
        Supports both direct download (https) and streaming (m3u8) formats.
        For m3u8 streams, uses FFmpeg to convert to MP4.
        
        Args:
            url: YouTube video URL
            output_dir: Local directory to save video
            
        Returns:
            Tuple of (video file path, video info dict)
            
        Raises:
            DownloadError: If all download strategies fail
        """
        download_start = time.time()
        
        logger.info(f"Starting download: URL={url[:50]}..., Resolution={self.resolution}")
        
        Path(output_dir).mkdir(parents=True, exist_ok=True)
        
        errors = []
        
        # NOTE: Smart download (URL extraction via AgentGo) is DISABLED
        # because YouTube video URLs are IP-bound. AgentGo extracts URLs with its IP,
        # but we download with a different IP (proxy), causing 403 Forbidden.
        # Instead, we use AgentGo only for Cookies + Visitor Data, and let yt-dlp
        # handle both URL extraction and download through the same proxy IP.
        
        # Direct yt-dlp strategies (uses proxy for both extraction and download)
        for strategy in [1, 2, 3]:
            try:
                logger.info(f"Trying yt-dlp strategy {strategy}...")
                result = await self._download_with_strategy(url, output_dir, strategy)
                
                duration = time.time() - download_start
                logger.info(f"Download succeeded with strategy {strategy} in {duration:.2f}s")
                return result
                
            except Exception as e:
                error_msg = f"Strategy {strategy} failed: {str(e)}"
                logger.warning(error_msg)
                errors.append(error_msg)
                
                if is_bot_detection_error(str(e)):
                    logger.warning("Bot detection encountered, trying next strategy...")
                continue
        
        # All strategies failed - try AgentGo fallback
        logger.info("All strategies failed, attempting AgentGo fallback...")
        try:
            result = await self._try_agentgo_fallback(url, output_dir)
            if result:
                duration = time.time() - download_start
                logger.info(f"AgentGo fallback succeeded in {duration:.2f}s")
                return result
        except Exception as e:
            errors.append(f"AgentGo fallback failed: {e}")
        
        raise DownloadError(f"All download attempts failed. Errors: {'; '.join(errors[-3:])}")
    
    async def _try_smart_download(
        self, 
        url: str, 
        output_dir: str
    ) -> Optional[Tuple[str, Dict[str, Any]]]:
        """
        Try smart download: extract URLs first, then use appropriate method.
        
        For m3u8 streams, uses FFmpeg conversion.
        For direct URLs, uses standard download.
        """
        try:
            from app.services.url_extractor import YouTubeURLExtractor, ExtractedVideo
            from app.services.stream_converter import convert_stream_to_mp4
            
            # Extract video info and URLs
            extractor = YouTubeURLExtractor(
                region=self.region,
                auth_bundle=self._auth_bundle
            )
            
            video = await extractor.extract(url)
            urls = video.get_download_urls(self.resolution)
            
            if not urls.get('video_url'):
                logger.warning("No video URL extracted")
                return None
            
            video_info = {
                'title': video.title,
                'duration': video.duration,
                'thumbnail': video.thumbnail,
                'description': video.description,
                'uploader': video.uploader,
            }
            
            # Check if we need stream conversion (m3u8)
            if urls.get('is_streaming'):
                logger.info("Detected m3u8 stream, using FFmpeg conversion...")
                
                output_file = await convert_stream_to_mp4(
                    video_url=urls['video_url'],
                    audio_url=urls.get('audio_url'),
                    output_dir=output_dir,
                    is_streaming=True,
                    needs_merge=urls.get('needs_merge', False),
                    filename=video.video_id,
                    timeout=600
                )
                
                return output_file, video_info
            
            # Direct download URL - can still use FFmpeg for consistency
            # or fall through to yt-dlp
            logger.info("Direct download URL available, using FFmpeg...")
            
            output_file = await convert_stream_to_mp4(
                video_url=urls['video_url'],
                audio_url=urls.get('audio_url'),
                output_dir=output_dir,
                is_streaming=False,
                needs_merge=urls.get('needs_merge', False),
                filename=video.video_id,
                timeout=600
            )
            
            return output_file, video_info
            
        except ImportError as e:
            logger.warning(f"Required module not available: {e}")
            return None
        except Exception as e:
            logger.warning(f"Smart download error: {e}")
            return None
    
    

    async def _try_agentgo_fallback(
        self,
        url: str,
        output_dir: str
    ) -> Optional[Tuple[str, Dict[str, Any]]]:
        """
        Try AgentGo to get fresh cookies and visitor_data, then retry download.
        
        Args:
            url: YouTube video URL
            output_dir: Output directory
            
        Returns:
            Tuple of (video file path, video info dict) if successful, None otherwise
        """
        try:
            from app.services.agentgo_service import get_agentgo_service
            
            service = get_agentgo_service()
            
            if not service.is_configured():
                logger.warning("AgentGo not configured")
                return None
            
            logger.info(f"Fetching authentication via AgentGo (region: {self.region or 'default'})...")
            auth_bundle = await service.get_youtube_authentication_bundle(
                force_refresh=True,
                region=self.region,
                video_url=url
            )
            
            if not auth_bundle:
                logger.error("Failed to get authentication from AgentGo")
                return None
            
            self.set_authentication_bundle(auth_bundle)
            
            # Retry with web client (bgutil will provide PO Token)
            try:
                result = await self._download_with_strategy(url, output_dir, 1)
                logger.info("AgentGo fallback succeeded!")
                return result
            except Exception as e:
                logger.warning(f"AgentGo fallback retry failed: {e}")
            
            return None
            
        except ImportError:
            logger.warning("AgentGo service not available")
            return None
        except Exception as e:
            logger.error(f"AgentGo fallback error: {e}")
            return None
    
    async def prefetch_authentication_for_region(self):
        """Pre-fetch authentication bundle for the configured region."""
        if not self.region:
            return
        
        try:
            from app.services.agentgo_service import get_agentgo_service
            
            service = get_agentgo_service()
            if not service.is_api_configured():
                return
            
            auth_bundle = await service.get_youtube_authentication_bundle(region=self.region)
            if auth_bundle and not auth_bundle.is_expired():
                self.set_authentication_bundle(auth_bundle)
                logger.info(f"Pre-fetched authentication for region: {self.region}")
                
        except Exception as e:
            logger.warning(f"Failed to prefetch authentication: {e}")
    
    async def _download_with_strategy(
        self, 
        url: str, 
        output_dir: str, 
        strategy: int
    ) -> Tuple[str, Dict[str, Any]]:
        """
        Download video using specific strategy.
        
        Args:
            url: YouTube video URL
            output_dir: Output directory
            strategy: Strategy number (1-3)
            
        Returns:
            Tuple of (video file path, video info dict)
        """
        opts = self._build_base_config()
        opts.update(self._get_strategy_config(strategy))
        opts['outtmpl'] = f"{output_dir}/%(id)s.%(ext)s"
        
        loop = asyncio.get_event_loop()
        
        def do_download():
            with yt_dlp.YoutubeDL(opts) as ydl:
                info = ydl.extract_info(url, download=True)
                filename = ydl.prepare_filename(info)
                return filename, info
        
        filename, info = await loop.run_in_executor(None, do_download)
        
        if not Path(filename).exists():
            raise DownloadError(f"Downloaded file not found: {filename}")
        
        video_info = {
            'title': info.get('title', 'Unknown'),
            'duration': info.get('duration', 0),
            'thumbnail': info.get('thumbnail'),
            'description': info.get('description'),
            'uploader': info.get('uploader'),
        }
        
        return filename, video_info


# Convenience function for quick downloads
async def download_youtube_video(
    url: str, 
    output_dir: str,
    region: Optional[str] = None,
    auth_bundle: Optional[AuthenticationBundle] = None,
    timeout: int = 300
) -> Tuple[str, Dict[str, Any]]:
    """
    Quick download function with timeout handling.
    
    Args:
        url: YouTube video URL
        output_dir: Output directory
        region: Geographic region for AgentGo
        auth_bundle: Optional authentication bundle
        timeout: Maximum time for download (seconds)
        
    Returns:
        Tuple of (video file path, video info dict)
        
    Raises:
        DownloadError: If download fails or times out
    """
    logger.info(f"Starting download: URL={url[:50]}..., Region={region or 'default'}")
    
    downloader = YouTubeDownloader(
        region=region,
        auth_bundle=auth_bundle
    )
    
    try:
        # Pre-fetch authentication if region specified
        if region and not auth_bundle:
            try:
                await asyncio.wait_for(
                    downloader.prefetch_authentication_for_region(),
                    timeout=60
                )
            except asyncio.TimeoutError:
                logger.warning("Authentication prefetch timed out, continuing...")
            except Exception as e:
                logger.warning(f"Authentication prefetch failed: {e}")
        
        result = await asyncio.wait_for(
            downloader.download(url, output_dir),
            timeout=timeout
        )
        
        return result
        
    except asyncio.TimeoutError:
        raise DownloadError(f"Download timed out after {timeout}s")
    except Exception as e:
        logger.error(f"Download failed: {e}")
        raise
